:og:description: Whipser based speech recognition authenticated aiohttp server
:og:keywords: whisper, speech recognition, authentication, server, client, python, ayoub malek, blog post
:og:image: ../../../../_static/meta_images/whisper_authenticated_aiohttp_server_with_token.png
:og:image:alt: whisper_authenticated_aiohttp_server_with_token

Token authenticated Whisper based speech recognition aiohttp server
===================================================================

.. post:: December 27, 2022
   :tags: Python, Server-client, Speech recognition, Whisper
   :category: Server-client
   :author: Ayoub Malek
   :location: Munich
   :language: English

-----------------------

In the last blog post, an authenticated aiohttp server was introduced. 
In this post, we build on top of the previous posts, to create a speech recognition server.
The speech recognition feature will be based on `whisper`_.

Why whisper?
~~~~~~~~~~~~~
The choice here is arbitrary, I chose whisper since it is simple to integrate and is very accurate.

Speech recognition implementation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
One way to implement this is to use the whisper cli tool using the subprocess library. 
This can be done as follows:

.. code-block:: python
 :caption: transcribe
 :linenos:

  import io
  import sys
  import time
  import asyncio
  import logging
  import whisper
  import subprocess
  import soundfile as sf


  async def stt(request):
      """
      Speech to text routine to transcribe incoming wave audio and deliver
      the resulting text in return.

      Args:
          request.

      Returns:
          Json response.
      """
      response = {}
      stime = time.time()
      bytes_data = await request.content.read()
      logger.debug("size of received bytes data: " + str(sys.getsizeof(bytes_data)) + " bytes")

      try:
          # save temp file
          audio, fs = sf.read(io.BytesIO(bytes_data), dtype="float32")
          result = model.transcribe(audio=audio)
          texts = result['text'] 
          tproc      = round(time.time() - stime, 3)
          response   = {"text": ' '.join(texts), "proc_duration": tproc, "status": "success"}
      
      except Exception as e:
          response   = {"Error": str(e), "status": "failed"}
          logger.error("-> Errror :" + str(e))

      return web.json_response(response)


As you see in the config, we are now able to configure the host and the port to run the server on.
We are also able to constraint the size of the accepted requests along with providing a list of accepted valid tokens.
Furthermore, we added a logger and a debug level to investigate possible errors.
The following section will detail the work.

.. code-block:: python
  :linenos:

  import io
  import sys
  import json
  import time
  import asyncio
  import logging
  import whisper
  import subprocess
  import soundfile as sf
  from aiohttp import web
  from typing import Callable, Coroutine, Tuple


  # init loggging
  logger = logging.getLogger(__name__)
  logging.basicConfig(format="[%(asctime)s.%(msecs)03d] p%(process)s {%(pathname)s: %(funcName)s: %(lineno)d}: %(levelname)s: %(message)s", datefmt="%Y-%m-%d %p %I:%M:%S")
  logger.setLevel(10)

  # set up model 
  model = whisper.load_model("base")

  # parse conf
  with open("config.json", "rb") as config_file:
      conf = json.loads(config_file.read())

  def ping(request):
      logger.debug("-> Received PING")
      response = web.json_response({"text": "pong", "status": "success"})
      return response

  async def stt(request):
      """
      Speech to text routine to transcribe incoming wave audio and deliver
      the resulting text in return.

      Args:
          request.

      Returns:
          Json response.
      """
      response = {}
      stime = time.time()
      bytes_data = await request.content.read()
      logger.debug("size of received bytes data: " + str(sys.getsizeof(bytes_data)) + " bytes")

      try:
          # save temp file
          audio, fs = sf.read(io.BytesIO(bytes_data), dtype="float32")
          result = model.transcribe(audio=audio)
          texts = result['text'] 
          tproc      = round(time.time() - stime, 3)
          response   = {"text": ' '.join(texts), "proc_duration": tproc, "status": "success"}
      
      except Exception as e:
          response   = {"Error": str(e), "status": "failed"}
          logger.error("-> Errror :" + str(e))

      return web.json_response(response)

  def token_auth_middleware(user_loader: Callable,
                      request_property: str = 'user',
                      auth_scheme: str = 'Token',
                      exclude_routes: Tuple = tuple(),
                      exclude_methods: Tuple = tuple()) -> Coroutine:
    """
    Checks a auth token and adds a user from user_loader in request.
    """
    @web.middleware
    async def middleware(request, handler):
        try               : scheme, token = request.headers['Authorization'].strip().split(' ')
        except KeyError   : raise web.HTTPUnauthorized(reason='Missing authorization header',)
        except ValueError : raise web.HTTPForbidden(reason='Invalid authorization header',)
              
        if auth_scheme.lower() != scheme.lower():
            raise web.HTTPForbidden(reason='Invalid token scheme',)

        user = await user_loader(token)
        if user : request[request_property] = user
        else    : raise web.HTTPForbidden(reason='Token doesn\'t exist')
        return await handler(request)
    return middleware

  async def init():
    """
    Init web application.
    """
    async def user_loader(token: str):
      user = {'uuid': 'fake-uuid'} if token in conf["server"]["http"]["allowed_tokens"] else None
      return user

    app = web.Application(client_max_size=conf["server"]["http"]["request_max_size"],
                  middlewares=[token_auth_middleware(user_loader)])
    
    app.router.add_route('GET', '/ping', ping)
    app.router.add_route('GET', '/stt', stt)
    return app

  if __name__ == '__main__':
    web.run_app(init(),)
    

2. **Load the configuration infos.**

   .. code-block:: python
    :linenos:

    import json

    # parse conf
    with open("config.json", "rb") as config_file:
        conf = json.loads(config_file.read())

3. **Write a request handler.**
   Requests in aiohttp are processed using coroutines that will serve as the actual functions called by the client.

   .. code-block:: python
    :linenos:

    import asyncio
    from aiohttp import web

    @asyncio.coroutine
    def ping(request):
        return web.json_response({"text": "pong", "status": "success"})

4. **Write the authentication and token handler**

   .. code-block:: python
    :linenos:

    import asyncio
    from aiohttp import web
    from typing import Callable, Coroutine, Tuple

    def token_auth_middleware(user_loader: Callable,
                              request_property: str = 'user',
                              auth_scheme: str = 'Token',
                              exclude_routes: Tuple = tuple(),
                              exclude_methods: Tuple = tuple()) -> Coroutine:
        """
        Checks a auth token and adds a user from user_loader in request.
        """
        @web.middleware
        async def middleware(request, handler):
            try               : scheme, token = request.headers['Authorization'].strip().split(' ')
            except KeyError   : raise web.HTTPUnauthorized(reason='Missing authorization header',)
            except ValueError : raise web.HTTPForbidden(reason='Invalid authorization header',)

            if auth_scheme.lower() != scheme.lower():
                raise web.HTTPForbidden(reason='Invalid token scheme',)

            user = await user_loader(token)
            if user : request[request_property] = user
            else    : raise web.HTTPForbidden(reason='Token doesn\'t exist')
            return await handler(request)
        return middleware

5. **Write the server init function and wrap it all.**

   .. code-block:: python
    :linenos:

    import asyncio
    from aiohttp import web

    async def init():
       """
       Init web application.
       """
       async def user_loader(token: str):
           user = {'uuid': 'fake-uuid'} if token in conf["server"]["http"]["allowed_tokens"] else None
           return user

       app = web.Application(client_max_size=conf["server"]["http"]["request_max_size"],
                             middlewares=[token_auth_middleware(user_loader)])
       app.router.add_route('GET', '/ping', ping)
       return app


    web.run_app(init(),)


Code
~~~~
The previously listed steps, should look together in Python as follows:

.. code-block:: python
  :caption: whisper-based-asr-aiohttp-server-with-token-auth
  :linenos:

  import io
  import sys
  import json
  import time
  import asyncio
  import logging
  import whisper
  import subprocess
  import soundfile as sf
  from aiohttp import web
  from typing import Callable, Coroutine, Tuple


  # init loggging
  logger = logging.getLogger(__name__)
  logging.basicConfig(format="[%(asctime)s.%(msecs)03d] p%(process)s {%(pathname)s: %(funcName)s: %(lineno)d}: %(levelname)s: %(message)s", datefmt="%Y-%m-%d %p %I:%M:%S")
  logger.setLevel(10)

  # parse conf
  with open("config.json", "rb") as config_file:
      conf = json.loads(config_file.read())

  def ping(request):
      logger.debug("-> Received PING")
      response = web.json_response({"text": "pong", "status": "success"})
      return response

  async def stt(request):
      """
      Speech to text routine to transcribe incoming wave audio and deliver
      the resulting text in return.

      Args:
          request.

      Returns:
          Json response.
      """
      response = {}
      stime      = time.time()
      bytes_data = await request.content.read()
      logger.debug("size of received bytes data: " + str(sys.getsizeof(bytes_data)) + " bytes")

      try:
          # save temp file
          temp_path = "temp/received_wave.wav"
          audio, fs = sf.read(io.BytesIO(bytes_data), dtype="int16")
          sf.write(file=temp_path, data=audio, samplerate=fs)
          
          # recognize
          process = subprocess.Popen(["whisper", 
                                      temp_path, 
                                      "--model", 
                                      "base", 
                                      "--language", 
                                      "en"],
                              stdout=subprocess.PIPE, 
                              stderr=subprocess.PIPE)
          stdout, stderr = process.communicate()
          results = stdout.decode("utf-8")
          texts   = "".join([seg.split("] ")[1] for seg in results.split("\n") if len(seg) > 1])
          logger.debug("transcribed text: " + str(texts))

          tproc      = round(time.time() - stime, 3)
          response   = {"text": ' '.join(texts), "proc_duration": tproc, "status": "success"}
      except Exception as e:
          response   = {"Error": str(e), "status": "failed"}
          logger.error("-> Errror :" + str(e))
      return web.json_response(response)

  def token_auth_middleware(user_loader: Callable,
                      request_property: str = 'user',
                      auth_scheme: str = 'Token',
                      exclude_routes: Tuple = tuple(),
                      exclude_methods: Tuple = tuple()) -> Coroutine:
    """
    Checks a auth token and adds a user from user_loader in request.
    """
    @web.middleware
    async def middleware(request, handler):
        try               : scheme, token = request.headers['Authorization'].strip().split(' ')
        except KeyError   : raise web.HTTPUnauthorized(reason='Missing authorization header',)
        except ValueError : raise web.HTTPForbidden(reason='Invalid authorization header',)
              
        if auth_scheme.lower() != scheme.lower():
            raise web.HTTPForbidden(reason='Invalid token scheme',)

        user = await user_loader(token)
        if user : request[request_property] = user
        else    : raise web.HTTPForbidden(reason='Token doesn\'t exist')
        return await handler(request)
    return middleware

  async def init():
    """
    Init web application.
    """
    async def user_loader(token: str):
      user = {'uuid': 'fake-uuid'} if token in conf["server"]["http"]["allowed_tokens"] else None
      return user

    app = web.Application(client_max_size=conf["server"]["http"]["request_max_size"],
                  middlewares=[token_auth_middleware(user_loader)])
    
    app.router.add_route('GET', '/ping', ping)
    app.router.add_route('GET', '/stt', stt)
    return app


  if __name__ == '__main__':
    web.run_app(init(),)


Testing
~~~~~~~~
The previous code when executed will start a server running on :code:`http://localhost:8080/`.
To test your server either type in your browser :code:`http://localhost:8080/ping` or simply curl_ it while passing your token using :code:`curl -H 'Authorization: Token token1' http://127.0.0.1:8080/ping`.
The response should be a json including pong and a success status.

Conclusion
~~~~~~~~~~
This blog presented an improved aiohttp server that implements token based authentication to filter out unwanted traffic and protect itself against possible spamming attacks
that could be part of DOS attacks.

Share this blog
~~~~~~~~~~~~~~~~

.. raw:: html

  <div id="share">
    <a class="facebook" href="https://www.facebook.com/share.php?u=https://superkogito.github.io/blog/2021/12/31/aiohttp_server_with_token.html&title=Token%20authenticated%20aiohttp%20Server"                target="blank"><i class="fa fa-facebook"></i></a>
    <a class="twitter"  href="https://twitter.com/intent/tweet?url=https://superkogito.github.io/blog/2021/12/31/aiohttp_server_with_token.html&text=Token%20authenticated%20aiohttp%20Server"                 target="blank"><i class="fa fa-twitter"></i></a>
    <a class="linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https://superkogito.github.io/blog/2021/12/31/aiohttp_server_with_token.html&title=Token%20authenticated%20aiohttp%20Server" target="blank"><i class="fa fa-linkedin"></i></a>
    <a class="reddit"   href="http://www.reddit.com/submit?url=https://superkogito.github.io/blog/2021/12/31/aiohttp_server_with_token.html&title=Token%20authenticated%20aiohttp%20Server"                    target="blank"><i class="fa fa-reddit"></i></a>
  </div>


.. update:: 8 Apr 2022

   👨‍💻 edited and review were on 08.04.2022


.. _aiohttp : https://docs.aiohttp.org/en/stable/
.. _curl : https://curl.se/
.. _whisper : https://github.com/openai/whisper