<!doctype html><html xmlns=http://www.w3.org/1999/xhtml><meta charset=utf-8><script>var _gaq=_gaq||[];_gaq.push(['_setAccount','UA-133660046-1']);_gaq.push(['_trackPageview']);(function(){var ga=document.createElement('script');ga.type='text/javascript';ga.async=true;ga.src=('https:'==document.location.protocol?'https://ssl':'http://www')+'.google-analytics.com/ga.js';var s=document.getElementsByTagName('script')[0];s.parentNode.insertBefore(ga,s);})();</script><title>Posts in 2020 â€” Ayoub Malek's blog</title><link href=../../_static/alabaster.css rel=stylesheet><link href=../../_static/pygments.css rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css rel=stylesheet><link href=../../_static/css/custom_style.css rel=stylesheet><script data-url_root=../../ id=documentation_options src=../../_static/documentation_options.js></script><script src=../../_static/jquery.js></script><script src=../../_static/underscore.js></script><script src=../../_static/doctools.js></script><script src=../../_static/language_data.js></script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><link href=../../_static/favicon.ico rel="shortcut icon"><link href=../../about.html rel=author title="About these documents"><link href=../../genindex.html rel=index title=Index><link href=../../search.html rel=search title=Search><link href=../../_static/custom.css rel=stylesheet><meta content="width=device-width,initial-scale=.9,maximum-scale=.9" name=viewport><link href=../../blog/atom.xml rel=alternate title="Posts in 2020" type=application/atom+xml><style>ul.ablog-archive{list-style:none;overflow:auto;margin-left:0}ul.ablog-archive li{float:left;margin-right:5px;font-size:80%}ul.postlist a{font-style:italic}ul.postlist-style-disc{list-style-type:disc}ul.postlist-style-none{list-style-type:none}ul.postlist-style-circle{list-style-type:circle}</style><meta content="width=device-width,initial-scale=1" name=viewport><div class=document><div class=documentwrapper><div class=body role=main><div class=section><h1>Posts in
2020</h1><div class=sub-title-menu><table class=menu-table id=menuTable style=border:hidden><tr><th><th><th class=icon><a href=../../index.html title=Home><i class="fa fa-home"></i></a><th class=menu-label><a href=../../index.html title=Home>Home</a><th><th><th class=icon><a href=../../posts.html title=Posts><i class="fa fa-bars"></i></a><th class=menu-label><a href=../../posts.html title=Posts>Posts</a><th><th><th class=icon><a href=../../publications.html title=pubs><i class="fa fa-file-text"></i></a><th class=menu-label><a href=../../publications.html title=pubs>Publications</a><th><th><th class=icon><a href=../../projects.html title=projects><i class="fa fa-code"></i></a><th class=menu-label><a href=../../projects.html title=projects>Projects</a><th><th><th class=icon><a href=../../games.html title=Games><i class="fa fa-gamepad"></i></a><th class=menu-label><a href=../../games.html title=Games>Games</a><th><th><th class=icon><a href=../../about.html title=About><i class="fa fa-user-circle"></i></a><th class=menu-label><a href=../../about.html title=About>About</a><th><th><th class=icon><a href=# onclick=modeSwitcher()><i class="fa fa-adjust"></i></a><th class=menu-label><a href=# onclick=modeSwitcher()><text id=theme-toggle>DARK MODE</text></a></table></div><div class=section><h2><a href=../DivideImageUsingGdiplus.html>Divide an image into blocks using GDI+ in C++</a></h2><ul class=ablog-archive><li>03 October 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=image-processing.html>Image processing</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/cplusplus.html>Cplusplus</a>
<a href=../tag/gdiplus.html>Gdiplus</a>
<a href=../tag/windows.html>Windows</a></ul><p>In the previous blog, we used OpenCV to divide an image into multiple blocks of a certain height and width, which is useful when we need to apply a certain image transformation block-wise.
This blog will provide an alternative implementation using the Windows API, specifically the <a class="reference external" href=https://docs.microsoft.com/en-us/windows/win32/gdiplus/-gdiplus-gdi-start>GDI+</a> library.<p><a href=../DivideImageUsingGdiplus.html>Read more ...</a><hr></div><div class=section><h2><a href=../DivideImageUsingOpenCv.html>Divide an image into blocks using OpenCV in C++</a></h2><ul class=ablog-archive><li>01 October 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=image-processing.html>Image processing</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/cplusplus.html>Cplusplus</a>
<a href=../tag/opencv.html>OpenCV</a>
<a href=../tag/windows.html>Windows</a></ul><p>Often you will need to divide an image into multiple blocks of a certain height and width to apply a certain transformation or would like to compare two images block-wise.
This blog will provide a short explanation and a C++ implementation for how to divide an image into multiple blocks with custom height and width.<p><a href=../DivideImageUsingOpenCv.html>Read more ...</a><hr></div><div class=section><h2><a href=../LoopMonitorsDetailsInCplusplus.html>How to loop over monitors and get their coordinates on Windows in C++?</a></h2><ul class=ablog-archive><li>28 September 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=image-processing.html>Image processing</a>,
<a href=#>2020</a><li id=tags><span>Tag:</span>
<a href=../tag/cplusplus.html>Cplusplus</a></ul><p>The previous three blogs (<a class="reference external" href=https://superkogito.github.io/blog/CaptureScreenUsingOpenCv.html>Capturing the screen on Windows in C++ using OpenCV</a> &amp; <a class="reference external" href=https://superkogito.github.io/blog/CaptureScreenUsingGdiplus.html>Capturing the screen on Windows in C++ using GDI+</a> and <a class="reference external" href=https://superkogito.github.io/blog/CaptureSceenshotUsingGdiplusVSCaptureSceenshotUsingOpenCV.html>Comparing screen capturing using GDI+ and OpenCV on Windows in C++</a>) described capturing a screenshot of only <em>one</em> monitor.
However, nowadays we often use multiple monitors and capturing the content of all of them or a specific one, two or more.
Therefore, we will need to retrieve the coordinates of the targeted monitors.
This blog will provide a short explanation and a C++ implementation for how to loop the existing monitors in a multiple monitors setup, get their dimensions and coordinates which can be used later into capturing the monitors content.<p><a href=../LoopMonitorsDetailsInCplusplus.html>Read more ...</a><hr></div><div class=section><h2><a href=../CaptureSceenshotUsingGdiplusVSCaptureSceenshotUsingOpenCV.html>Comparing screen capturing using GDI+ and OpenCV on Windows in C++</a></h2><ul class=ablog-archive><li>28 July 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=image-processing.html>Image processing</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/cplusplus.html>Cplusplus</a>
<a href=../tag/windows.html>Windows</a>
<a href=../tag/gdiplus.html>Gdiplus</a>
<a href=../tag/opencv.html>OpenCV</a>
<a href=../tag/screenshot.html>Screenshot</a></ul><p>To follow up on my last two blogs (<a class="reference external" href=https://superkogito.github.io/blog/CaptureScreenUsingOpenCv.html>Capturing the screen on Windows in C++ using OpenCV</a> &amp; <a class="reference external" href=https://superkogito.github.io/blog/CaptureScreenUsingGdiplus.html>Capturing the screen on Windows in C++ using GDI+</a> ), we compare in this post both approaches.
In order to compare both approaches, we examines their run-times and CPU usages.<p><a href=../CaptureSceenshotUsingGdiplusVSCaptureSceenshotUsingOpenCV.html>Read more ...</a><hr></div><div class=section><h2><a href=../CaptureScreenUsingGdiplus.html>Capturing the screen on Windows in C++ using GDI+</a></h2><ul class=ablog-archive><li>26 July 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=image-processing.html>Image processing</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/cplusplus.html>Cplusplus</a>
<a href=../tag/gdiplus.html>Gdiplus</a>
<a href=../tag/windows.html>Windows</a>
<a href=../tag/screenshot.html>Screenshot</a></ul><p><a class="reference external" href=https://docs.microsoft.com/en-us/windows/win32/gdiplus/-gdiplus-gdi-start>GDI+/ Gdiplus</a> is part of the <a class="reference external" href=https://docs.microsoft.com/en-us/windows/win32/>Win32 API</a>, that helps C/C++ programmers with graphics related tasks on Windows.
In this blog, we will be writing a simple algorithm to capture the content of the screen on Windows using Gdiplus in C++.<p><a href=../CaptureScreenUsingGdiplus.html>Read more ...</a><hr></div><div class=section><h2><a href=../CaptureScreenUsingOpenCv.html>Capturing the screen on Windows in C++ using OpenCV</a></h2><ul class=ablog-archive><li>25 July 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=image-processing.html>Image processing</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/cplusplus.html>Cplusplus</a>
<a href=../tag/windows.html>Windows</a>
<a href=../tag/opencv.html>OpenCV</a>
<a href=../tag/screenshot.html>Screenshot</a></ul><p>OpenCV is just a great computer vision tool with a wide variety of capabilities, that is available in both C++ and Python.
In this first blog about OpenCV, I will be introducing a simple algorithm to capture the content of the screen on Windows using OpenCV in C++.<p><a href=../CaptureScreenUsingOpenCv.html>Read more ...</a><hr></div><div class=section><h2><a href=../rmsnormalization.html>Root mean square normalization in Python</a></h2><ul class=ablog-archive><li>30 April 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=signal-processing.html>Signal processing</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/python.html>Python</a>
<a href=../tag/augmentation.html>Augmentation</a>
<a href=../tag/audio.html>Audio</a></ul><p>Audio normalization is a fundamental audio processing technique that consists of applying a constant amount of gain to an audio in order to bring its amplitude to a target level.
A commonly used normalization technique is the Root Mean Square (RMS) normalization. This blog post introduces RMS normalization and provides a Python implementation of it.<p><a href=../rmsnormalization.html>Read more ...</a><hr></div><div class=section><h2><a href=../urlstechie.html>Introducing urlstechie and its urls checking tools</a></h2><ul class=ablog-archive><li>04 April 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=automation.html>Automation</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/continuous-integration.html>Continuous integration</a>
<a href=../tag/urlstechie.html>urlstechie</a>
<a href=../tag/python.html>Python</a></ul><p>Continuous testing is a vital part of any healthy software development process.
Urls must always be tested and broken links must be fixed to guarantee a high quality product.
Unfortunately, this is not always trivial and can be tedious.
Moreover, most tools available out there cannot handle in-code urls and lack many other needed features.
A while back, I ran across this particular Problem and I quickly saw the great automation opportunity this was, and how can Python and Regex help me solve this.
This was the start of the urlchecker-action â€¦ from there and with the amazing <a class="reference external" href=https://github.com/vsoch>@vsoch</a> joining, the tools expanded and this was the start of the urlstechie organization.<p><a href=../urlstechie.html>Read more ...</a><hr></div><div class=section><h2><a href=../ffmpegpipe.html>How to pipe an FFmpeg output and pass it to a Python variable?</a></h2><ul class=ablog-archive><li>19 March 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=signal-processing.html>Signal processing</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/python.html>Python</a>
<a href=../tag/ffmpeg.html>Ffmpeg</a>
<a href=../tag/audio.html>Audio</a></ul><p>When writing code, the key optimization points are speed and efficiency.
I often face this dilemma when using FFmpeg with Python.
For example: when I need to convert an mp3 to a wave file and then do some processing to it in Python.
The simple way to do this, is by using FFmpeg to convert the mp3 input to a wave, then read the wave in Python and do process it.
Although this works, but clearly it is neither optimal nor the fastest solution.
In this blog post, I will present an improved solution to this inconvenience by piping the output of FFmpeg to Python and directly pass it to a numpy variable.<p><a href=../ffmpegpipe.html>Read more ...</a><hr></div><div class=section><h2><a href=../SpectralLeakageWindowing.html>Spectral leakage and windowing</a></h2><ul class=ablog-archive><li>13 March 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=signal-processing.html>Signal processing</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/audio.html>Audio</a>
<a href=../tag/python.html>Python</a></ul><p>Windowing is an important part of almost any signal processing system, that helps remove/ reduce spectral leakage when processing a non-periodic signal.
This blog post provides a small overview of what is spectral usage, when does it occur and how to use windowing to suppress it.<p><a href=../SpectralLeakageWindowing.html>Read more ...</a><hr></div><div class=section><h2><a href=../NaiveVad.html>Naive voice activity detection using short time energy</a></h2><ul class=ablog-archive><li>09 February 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=signal-processing.html>Signal processing</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/python.html>Python</a>
<a href=../tag/vad.html>VAD</a>
<a href=../tag/audio.html>Audio</a></ul><p>An important part of speech/speaker recognition tasks is distinction of voiced segments from silent ones.
This helps -for example- align phonemes with their associated voiced segments and avoid any extra information related to silence/ noise that would degrade the systemâ€™s accuracy.
This problem is known as Voice Activity Detection (VAD). This blog aims to introduce voice activity detection and present simple short time energy based VAD implementation.<p><a href=../NaiveVad.html>Read more ...</a><hr></div><div class=section><h2><a href=../SignalFraming.html>Signal framing</a></h2><ul class=ablog-archive><li>25 January 2020<li id=author><span>Author:</span>
<a href=../author/ayoub-malek.html>Ayoub Malek</a><li id=location><span>Location:</span>
<a href=../location/munich.html>Munich</a><li id=language><span>Language:</span>
<a href=../language/english.html>English</a><li id=category><span>Category:</span>
<a href=signal-processing.html>Signal processing</a>,
<a href=#>2020</a><li id=tags><span>Tags:</span>
<a href=../tag/python.html>Python</a>
<a href=../tag/framing.html>Framing</a>
<a href=../tag/audio.html>Audio</a></ul><p>When it comes to non-stationary signals, spectral features in short parts/ sequences are of great use.
Therefore, decomposing the signal into multiple ranges is the way to go about this type of features extraction.
This technique is known as frame blocking or framing. The following blog explains why do we need framing and how to do it in python.<p><a href=../SignalFraming.html>Read more ...</a><hr></div></div></div></div><div class=clearer></div></div><div class=footer>Â©2020, Ayoub Malek.
|
Powered by <a href=http://sphinx-doc.org/>Sphinx 2.3.1</a>
&amp; <a href=https://github.com/bitprophet/alabaster>Alabaster 0.7.11</a></div><script async defer src=https://buttons.github.io/buttons.js></script><script src=../../_static/js/mode-switcher.js></script>